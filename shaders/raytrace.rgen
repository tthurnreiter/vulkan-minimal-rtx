#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : require

#include "../src/common.h"
#include "shaderCommon.h"

layout(binding = BINDING_IMAGE, set = 0, rgba32f) uniform image2D storageImage;
layout(binding = BINDING_TLAS, set = 0) uniform accelerationStructureEXT tlas;

layout(location = 0) rayPayloadEXT PassableInfo pld;

void main()
{
  const ivec2 resolution = imageSize(storageImage);
  const ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);

  if(pixel.x >= resolution.x || pixel.y >= resolution.y){
    debugPrintfEXT("RGEN Early exit! pixel.xy: %d|%d, resolution.xy: %d|%d\n", pixel.x, pixel.y, resolution.x, resolution.y);
    return;
  }

  //const vec3 camPos = vec3(-0.001, 1.0, 6.0);
  const vec3 camPos = vec3(-516,300,0);
  const vec3 camUp = vec3(0,1,0);
  const vec3 camDir = vec3(1,0,0);

  vec3 U = cross(camDir, camUp);
  vec3 V = cross(U, camDir);

  float fovy = 65;
  float aspect = float(resolution.x)/resolution.y;
  float near_h = tan(float(M_PI) * fovy * 0.5f / 180.0f);
  float near_w = aspect*near_h;

  float u = (float(pixel.x)+0.5f)/float(resolution.x) * 2.0f - 1.0f;
  float v = (float(pixel.y)+0.5f)/float(resolution.y) * 2.0f - 1.0f;
  u = near_w*u;
  v = near_h*v;

  vec3 rayO = camPos;
  vec3 rayDir = normalize(camDir + U*u + V*v);

  const float fovVerticalSlope = 1.0/5.0;
  const vec2 screenUV = vec2( (2.0*pixel.x - resolution.x) / resolution.y,
                             -(2.0*pixel.y - resolution.y) / resolution.y);
  vec3 rayDirection = vec3(fovVerticalSlope*screenUV.x, fovVerticalSlope * screenUV.y, 1.0);
  rayDirection = normalize(rayDirection);
  

  float tmax = 100000.0f;
  traceRayEXT(tlas,
              gl_RayFlagsOpaqueEXT,
              0xFF,
              0,
              0,
              0,
              rayO,
              0.0,
              rayDir,
              tmax,
              0);
  
  vec4 color;
  if(pld.rayHitSky == true){
    color = vec4(0.0f, 0.0f, 0.5f, 0.0f);
  }
  else{  
    float tmp = clamp(pld.hitT/10000, 0, 1);
    color = vec4(tmp, 0.0f, 0.0f, 0.0f);
  }
  imageStore(storageImage, pixel, color);
}