//This file contains the ray generation shader that is called exactly once for every pixel in the image

#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#include "../src/common.h"
#include "shaderCommon.h"

#ifdef DEBUG
#extension GL_EXT_debug_printf : require
#endif //DEBUG

layout(binding = BINDING_IMAGE, set = 0, rgba32f) uniform image2D storageImage;
layout(binding = BINDING_TLAS, set = 0) uniform accelerationStructureEXT tlas;

layout(location = 0) rayPayloadEXT RayPayload pld;

layout(push_constant) uniform PushConsts
{
  PushConstants pushConstants;
};

void main()
{
  //get image resolution and which pixel this shader works on
  const ivec2 resolution = imageSize(storageImage);
  const ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);

  /*if(pixel.x >= resolution.x || pixel.y >= resolution.y){
    debugPrintfEXT("RGEN Early exit! pixel.xy: %d|%d, resolution.xy: %d|%d\n", pixel.x, pixel.y, resolution.x, resolution.y);
    return;
  }*/

  const vec3 camPos = vec3(pushConstants.camPosX, pushConstants.camPosY, pushConstants.camPosZ);
  const vec3 camDir = vec3(pushConstants.camDirX, pushConstants.camDirY, pushConstants.camDirZ);
  const vec3 U = vec3(pushConstants.Ux, pushConstants.Uy, pushConstants.Uz);
  const vec3 V = vec3(pushConstants.Vx, pushConstants.Vy, pushConstants.Vz);
  

  /*
  float fovy = 65;
  float aspect = float(resolution.x)/resolution.y;
  float near_h = tan(float(M_PI) * fovy * 0.5f / 180.0f);
  float near_w = aspect*near_h;
  float offsetX = 0;
  float offsetY = 0;
  float u = (float(pixel.x)+0.5f+offsetX)/float(resolution.x) * 2.0f - 1.0f;
	float v = (float(pixel.y)+0.5f+offsetY)/float(resolution.y) * 2.0f - 1.0f;
  u = u*pushConstants.near_w;
  v = v*pushConstants.near_h; */
  
  // u = (x + 0.5 + offsetX) * (2*near_w)/w - near_w
  float u = float(pixel.x+0.5) * pushConstants.term1u - pushConstants.near_w;
  float v = float(pixel.y+0.5) * pushConstants.term1v - pushConstants.near_h;

  vec3 rayO = camPos;
  vec3 rayDir = normalize(camDir + U*u + V*v);

/*   vec3 rayO = vec3(-516, 300, 0);
  vec3 rayDir = vec3(0.980478, 0.196627, 0.000521);
 */
  float tmax = 10000.0f;

  traceRayEXT(tlas,                 // top level acceleration structure
              gl_RayFlagsOpaqueEXT, // ray flags (all geometry is opaque)
              0xFF,                 // cull mask (0xFF => intersect all objects/instances)
              0,                    // SBT record offset
              0,                    // SBT record stride
              0,                    // miss index
              rayO,                 // ray origin
              0.0,                  // minimum T-value
              rayDir,               // ray direction
              tmax,                 // maximum T-value
              0);                   //location of ray payload
  
  vec4 color;
  /*if(pld.rayHitSky == true){
    color = vec4(0.0f, 0.0f, 0.5f, 0.0f);
  }
  else{
    float tmp = clamp(pld.hitT/10000, 0, 1);
    color = vec4(tmp, 0.0f, 0.0f, 0.0f);
  }*/
  
  color = vec4(float(pld.hitID), float(pld.hitID), float(pld.hitID), 0.0f);
  imageStore(storageImage, pixel, color);
}